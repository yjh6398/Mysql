当多个用户访问同一份数据时，一个用户在更改数据的过程中可能有其他用户同时发起更改请求，为保证数据的更新从一个一致性状态变更为另外一个一致性状态，这时就有必要引入事务的概念。

事务的四个特性：
（1）原子性:事务中所有的操作都视为一个原子单元，即对于数据的修改等操作只能是完全提交或者完全回滚。
（2）一致性：事务在完成时，必须使所有的数据从一种一致性状态变更为另外一种一致性状态，所有的变更都应用于事务的修改，以确保数据的完整性。
（3）隔离性：一个事务中的操作语句所做的修改必须与其他事务所做的修改相隔离。在进行事务查看数据数据所处的状态，要么是被另一并发事务修改之前的状态，要么是被另一并发事务修改之后的状态，即当前事务不会查看由另一个并发事务正在修改的数据，这种特性由锁机制实现。
（4）持久性：事务完成之后，所做的修改对数据的影响是永久的，即使系统重启或者系统出现故障，数据依然可以恢复。

MySQL事务控制语句
  开启一个事务 begin
  提交事务     commit
  回滚事务     rollback

MySQL事务隔离级别
  MySQL中总共有以下四个隔离级别，默认的事务隔离级别是repeatable read；

  1.Read-uncommitted(读取未提交内容)

  可能发生脏读：某个事务已经更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个进行了回滚操作，则后一个事务中读取的数据就会不正确。

  2.Read-committed（读取提交内容）：一个事务从开始到提交前所做的任何改变都是不可见的，事务只能看见已经提交事务所做的改变。

  可能会导致不可重复读：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中插入了一个事务更新的原有的数据。

  3.repeatale-read（可重读）：可以确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。
  可能发生幻读：在一个事务的两次查询中数据的记录总数不一致，例如有一个事务查询语句查询了几列数据，而另一个事务在此时却插入了几列新的数据，先前的事务在接下来的查询中，就会发现几列数据在先前是没有的。

 4.Serializable（可串行化）
　最高的隔离级别，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。

  查询当前会话的隔离级别
  select @@tx_isolation;
  查询系统当前的隔离级别
  select @@global.tx_isolation
  设置当前会话隔离级别
  set session transaction isolation level [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|     SERIALIZABLE]
  设置系统当前会话隔离级别
  set global transaction isolation level [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|     SERIALIZABLE];
   
  
  

